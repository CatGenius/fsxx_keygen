#include	<stdio.h>
#include	<stdlib.h>

//
// Definizioni di sostituzione
//
#define		FALSE		0
#define		TRUE		1

#define		DECRYPT		0
#define		ENCRYPT		1

//
// Definizione struttura opzione
//
typedef struct _option_type 
{
    unsigned long       raw_option;     // Valore RAW opzione
    unsigned char       valid_option;   // Validita' opzione
    char *              descr_option;   // Descirzione opzione

} option_type;

//
// Opzioni ammesse
//
// 1 - Seed Key    
// 2 - "TRUE" Funziona su FSP / "FALSE" Non funziona su FSP, forse su altri dispositivi
// 3 - Descrizione opzione
//
option_type  option_list[] = 
{
	{ 0x069AF1C1, TRUE,  "K5  - GSM/EDGE Application Firmware" },
	{ 0x0632E6E4, TRUE,  "K7  - AM/FM/PM Measurement Demodulator" },
	{ 0x2AAC5519, TRUE,  "B17 - IQ Online" },
	{ 0x081B95E1, FALSE, "None" },
	{ 0x2E03E151, TRUE,  "K84 - 1xEV-DO BTS Application Firmware" },
	{ 0x19EF1119, TRUE,  "K84 - 1xEV-DO MS  Application Firmware" },
	{ 0x310EE121, FALSE, "None" },
	{ 0x1756CE90, FALSE, "FSP-B15 FSP-B70 FS-K7" },
	{ 0x1919A691, FALSE, "K72 prior K74" },
	{ 0x03DAD7E4, FALSE, "None" },
	{ 0x2196F099, TRUE,  "K9  - Power Meter" },
	{ 0x3DD9B339, FALSE, "FSP-B15 FS-K7" },
	{ 0x0E395E40, FALSE, "None" },
	{ 0x195B9344, FALSE, "None" },
	{ 0x2C7CE440, TRUE,  "K76 - 3GPP TD-SCDMA BTS Application Firmware" },
	{ 0x08B0D139, TRUE,  "K77 - 3GPP TD-SCDMA MS  Application Firmware" },
	{ 0x13DE9644, TRUE,  "K30 - Noise Figure Measurament" },
	{ 0x0CFD9839, TRUE,  "K82 - CDMA2000 BTS Application Firmware" },
	{ 0x1AF16EA9, TRUE,  "K83 - CDMA2000 MS  Application Firmware" },
	{ 0x11E04FA4, TRUE,  "K8  - Bluetooth Application Firmware" },
	{ 0x0BF1BE90, TRUE,  "K40 - Phase Noise Measurament" },
	{ 0x03685351, FALSE, "None" },
	{ 0x1A368DB9, FALSE, "None" },
	{ 0x3A8A28B9, FALSE, "None" },
	{ 0x03BA3B10, FALSE, "None" },
	{ 0x0AF61A31, FALSE,  "31 days trial period" },
	{ 0x053D6400, FALSE,  "78 days trial period" },
	{ 0x0D659100, FALSE, "None" },
	{ 0x3F26B9A4, FALSE, "None" },
	{ 0x2626FF90, FALSE,  "Frequency Extension" },
	{ 0x1E0D3564, FALSE, "None" },
	{ 0x26E9C161, FALSE,  "Trasducer Set" },
	{ 0x2EFDA244, FALSE, "None" },
	{ 0x16BF9900, FALSE, "None" },
	{ 0x0EAFB3A1, FALSE, "None" },
	{ 0x36C143D9, FALSE, "None" },
	{ 0x0F64FEB1, FALSE, "None" },
	{ 0x1CC87A91, FALSE, "None" },
	{ 0x3C3E8900, FALSE, "None" },
	{ 0x3936AC24, FALSE, "None" },
	{ 0x2C810F89, FALSE, "None" },
	{ 0x2C2CFE40, FALSE, "None" },
	{ 0x08BA6899, FALSE, "None" },
	{ 0x20230E90, FALSE, "None" },
	{ 0x157EA044, FALSE, "None" },
	{ 0x39D8CC61, FALSE, "None" },
	{ 0x19C84B04, FALSE, "None" },
	{ 0x13B57040, FALSE, "None" },
	{ 0x30D449C4, FALSE, "None" },
	{ 0x20418E41, FALSE, "None" },
	{ 0, 0, 0 }
};

//
// Valori per Addizione/Sottrazione da opzione
//
const unsigned long tavola[] = 
{
	0x07D00D940, 0x08488D256, 0x11FBDB21, 0x08838C862, 
	0x0CF78A3D3, 0x07CBCB35C, 0x5F7C7140, 0x0CCBD55D8, 
	0x01115AE60, 0x0E940852B, 0x651F66D0, 0x0BF9CF792,
	0x0DEFCD8D5, 0x0082D0E96, 0x0CD7B345, 0x0A64FD784	
};

//
// Tavola di permutazione funzione chiper decrypt
//
const unsigned char tavola_decrypt[512] =
{
    0x09, 0x0A, 0x04, 0x1F, 0x1D, 0x15, 0x06, 0x17, 0x1E, 0x1B, 0x1C, 0x0E, 0x10, 0x02, 0x07, 0x0D, 
    0x03, 0x05, 0x16, 0x08, 0x0C, 0x19, 0x18, 0x00, 0x1A, 0x01, 0x14, 0x0B, 0x12, 0x13, 0x11, 0x0F,     
	0x1F, 0x0C, 0x1B, 0x11, 0x0D, 0x09, 0x0A, 0x15, 0x08, 0x04, 0x07, 0x1A, 0x17, 0x06, 0x01, 0x13, 
    0x03, 0x0B, 0x0E, 0x05, 0x0F, 0x00, 0x16, 0x19, 0x12, 0x14, 0x1C, 0x02, 0x10, 0x1D, 0x1E, 0x18,     
	0x0E, 0x02, 0x0D, 0x06, 0x1C, 0x12, 0x18, 0x0B, 0x0F, 0x1A, 0x16, 0x04, 0x1E, 0x05, 0x00, 0x1D, 
    0x03, 0x13, 0x11, 0x01, 0x08, 0x07, 0x0C, 0x1F, 0x10, 0x17, 0x19, 0x15, 0x14, 0x1B, 0x09, 0x0A,     
	0x0D, 0x0F, 0x1E, 0x19, 0x0E, 0x10, 0x0B, 0x13, 0x02, 0x14, 0x17, 0x01, 0x12, 0x05, 0x00, 0x09, 
    0x03, 0x11, 0x0A, 0x06, 0x08, 0x15, 0x1C, 0x16, 0x1B, 0x1F, 0x1A, 0x18, 0x1D, 0x0C, 0x04, 0x07,     
	0x10, 0x19, 0x08, 0x02, 0x05, 0x11, 0x16, 0x06, 0x07, 0x03, 0x0D, 0x14, 0x1C, 0x12, 0x1A, 0x18, 
    0x1E, 0x13, 0x1F, 0x1D, 0x0A, 0x01, 0x0E, 0x00, 0x0C, 0x09, 0x15, 0x1B, 0x17, 0x0B, 0x0F, 0x04,     
	0x18, 0x1C, 0x13, 0x09, 0x0F, 0x01, 0x05, 0x11, 0x00, 0x03, 0x17, 0x1A, 0x06, 0x1D, 0x10, 0x1F, 
    0x0D, 0x12, 0x02, 0x16, 0x19, 0x0C, 0x08, 0x04, 0x0B, 0x15, 0x0A, 0x07, 0x1E, 0x1B, 0x14, 0x0E,     
	0x10, 0x0A, 0x09, 0x04, 0x14, 0x08, 0x1F, 0x00, 0x1D, 0x05, 0x1B, 0x02, 0x0B, 0x12, 0x15, 0x03, 
    0x0E, 0x13, 0x19, 0x16, 0x1E, 0x11, 0x0C, 0x17, 0x0D, 0x0F, 0x1A, 0x01, 0x1C, 0x07, 0x06, 0x18,     
	0x05, 0x14, 0x1B, 0x0E, 0x06, 0x03, 0x07, 0x0A, 0x04, 0x11, 0x00, 0x01, 0x1F, 0x09, 0x18, 0x16, 
    0x1A, 0x15, 0x0F, 0x1D, 0x08, 0x17, 0x02, 0x0D, 0x12, 0x10, 0x1C, 0x1E, 0x0B, 0x0C, 0x13, 0x19,     
	0x06, 0x1E, 0x17, 0x07, 0x0A, 0x0E, 0x1D, 0x08, 0x0B, 0x14, 0x12, 0x01, 0x15, 0x0C, 0x09, 0x1F, 
    0x19, 0x00, 0x0D, 0x16, 0x02, 0x04, 0x13, 0x0F, 0x18, 0x1B, 0x1C, 0x11, 0x1A, 0x05, 0x10, 0x03,     
	0x16, 0x1B, 0x1F, 0x10, 0x12, 0x1A, 0x07, 0x0E, 0x0C, 0x02, 0x08, 0x1C, 0x13, 0x14, 0x05, 0x17, 
    0x19, 0x03, 0x1D, 0x1E, 0x15, 0x0D, 0x0B, 0x01, 0x00, 0x06, 0x18, 0x0A, 0x0F, 0x11, 0x04, 0x09,     
	0x0F, 0x17, 0x07, 0x1B, 0x18, 0x05, 0x1D, 0x0C, 0x1E, 0x08, 0x19, 0x0A, 0x11, 0x00, 0x1C, 0x0E, 
    0x02, 0x13, 0x16, 0x1F, 0x1A, 0x04, 0x0D, 0x06, 0x15, 0x12, 0x01, 0x10, 0x14, 0x03, 0x09, 0x0B,     
	0x08, 0x0A, 0x05, 0x1F, 0x1C, 0x09, 0x15, 0x19, 0x1E, 0x03, 0x13, 0x1A, 0x04, 0x14, 0x17, 0x01, 
    0x16, 0x06, 0x00, 0x0C, 0x10, 0x0D, 0x02, 0x0E, 0x1D, 0x07, 0x0F, 0x0B, 0x11, 0x18, 0x1B, 0x12,     
	0x17, 0x0A, 0x0B, 0x1C, 0x1B, 0x00, 0x19, 0x0E, 0x03, 0x11, 0x18, 0x0C, 0x07, 0x02, 0x05, 0x04, 
    0x1A, 0x01, 0x15, 0x12, 0x10, 0x08, 0x16, 0x06, 0x1E, 0x1F, 0x0D, 0x14, 0x1D, 0x09, 0x0F, 0x13,     
	0x0A, 0x15, 0x1F, 0x1B, 0x06, 0x07, 0x13, 0x1D, 0x02, 0x0D, 0x17, 0x1C, 0x12, 0x00, 0x1E, 0x16, 
    0x1A, 0x01, 0x05, 0x0C, 0x09, 0x03, 0x08, 0x10, 0x19, 0x0F, 0x11, 0x18, 0x0E, 0x0B, 0x04, 0x14,     
	0x05, 0x12, 0x0E, 0x03, 0x01, 0x02, 0x0B, 0x18, 0x17, 0x0A, 0x15, 0x13, 0x0D, 0x16, 0x1D, 0x07, 
    0x14, 0x1C, 0x1A, 0x10, 0x00, 0x0C, 0x06, 0x1B, 0x11, 0x0F, 0x04, 0x1E, 0x08, 0x1F, 0x19, 0x09,     
	0x1E, 0x1C, 0x05, 0x0E, 0x14, 0x18, 0x06, 0x15, 0x0D, 0x13, 0x0C, 0x10, 0x08, 0x1F, 0x19, 0x12, 
    0x04, 0x0B, 0x1D, 0x16, 0x03, 0x07, 0x00, 0x1A, 0x09, 0x1B, 0x11, 0x02, 0x0A, 0x0F, 0x01, 0x17, 
};

//
// Tavola di permutazione funzione chiper encrypt
//
unsigned char tavola_encrypt[512] =
{
    0x17, 0x19, 0x0D, 0x10, 0x02, 0x11, 0x06, 0x0E, 0x13, 0x00, 0x01, 0x1B, 0x14, 0x0F, 0x0B, 0x1F, 
    0x0C, 0x1E, 0x1C, 0x1D, 0x1A, 0x05, 0x12, 0x07, 0x16, 0x15, 0x18, 0x09, 0x0A, 0x04, 0x08, 0x03, 
    0x15, 0x0E, 0x1B, 0x10, 0x09, 0x13, 0x0D, 0x0A, 0x08, 0x05, 0x06, 0x11, 0x01, 0x04, 0x12, 0x14, 
    0x1C, 0x03, 0x18, 0x0F, 0x19, 0x07, 0x16, 0x0C, 0x1F, 0x17, 0x0B, 0x02, 0x1A, 0x1D, 0x1E, 0x00, 
    0x0E, 0x13, 0x01, 0x10, 0x0B, 0x0D, 0x03, 0x15, 0x14, 0x1E, 0x1F, 0x07, 0x16, 0x02, 0x00, 0x08, 
    0x18, 0x12, 0x05, 0x11, 0x1C, 0x1B, 0x0A, 0x19, 0x06, 0x1A, 0x09, 0x1D, 0x04, 0x0F, 0x0C, 0x17, 
    0x0E, 0x0B, 0x08, 0x10, 0x1E, 0x0D, 0x13, 0x1F, 0x14, 0x0F, 0x12, 0x06, 0x1D, 0x00, 0x04, 0x01, 
    0x05, 0x11, 0x0C, 0x07, 0x09, 0x15, 0x17, 0x0A, 0x1B, 0x03, 0x1A, 0x18, 0x16, 0x1C, 0x02, 0x19, 
    0x17, 0x15, 0x03, 0x09, 0x1F, 0x04, 0x07, 0x08, 0x02, 0x19, 0x14, 0x1D, 0x18, 0x0A, 0x16, 0x1E, 
    0x00, 0x05, 0x0D, 0x11, 0x0B, 0x1A, 0x06, 0x1C, 0x0F, 0x01, 0x0E, 0x1B, 0x0C, 0x13, 0x10, 0x12, 
    0x08, 0x05, 0x12, 0x09, 0x17, 0x06, 0x0C, 0x1B, 0x16, 0x03, 0x1A, 0x18, 0x15, 0x10, 0x1F, 0x04, 
    0x0E, 0x07, 0x11, 0x02, 0x1E, 0x19, 0x13, 0x0A, 0x00, 0x14, 0x0B, 0x1D, 0x01, 0x0D, 0x1C, 0x0F, 
    0x07, 0x1B, 0x0B, 0x0F, 0x03, 0x09, 0x1E, 0x1D, 0x05, 0x02, 0x01, 0x0C, 0x16, 0x18, 0x10, 0x19, 
    0x00, 0x15, 0x0D, 0x11, 0x04, 0x0E, 0x13, 0x17, 0x1F, 0x12, 0x1A, 0x0A, 0x1C, 0x08, 0x14, 0x06, 
    0x0A, 0x0B, 0x16, 0x05, 0x08, 0x00, 0x04, 0x06, 0x14, 0x0D, 0x07, 0x1C, 0x1D, 0x17, 0x03, 0x12, 
    0x19, 0x09, 0x18, 0x1E, 0x01, 0x11, 0x0F, 0x15, 0x0E, 0x1F, 0x10, 0x02, 0x1A, 0x13, 0x1B, 0x0C, 
    0x11, 0x0B, 0x14, 0x1F, 0x15, 0x1D, 0x00, 0x03, 0x07, 0x0E, 0x04, 0x08, 0x0D, 0x12, 0x05, 0x17, 
    0x1E, 0x1B, 0x0A, 0x16, 0x09, 0x0C, 0x13, 0x02, 0x18, 0x10, 0x1C, 0x19, 0x1A, 0x06, 0x01, 0x0F, 
    0x18, 0x17, 0x09, 0x11, 0x1E, 0x0E, 0x19, 0x06, 0x0A, 0x1F, 0x1B, 0x16, 0x08, 0x15, 0x07, 0x1C, 
    0x03, 0x1D, 0x04, 0x0C, 0x0D, 0x14, 0x00, 0x0F, 0x1A, 0x10, 0x05, 0x01, 0x0B, 0x12, 0x13, 0x02, 
    0x0D, 0x1A, 0x10, 0x1D, 0x15, 0x05, 0x17, 0x02, 0x09, 0x1E, 0x0B, 0x1F, 0x07, 0x16, 0x0F, 0x00, 
    0x1B, 0x0C, 0x19, 0x11, 0x1C, 0x18, 0x12, 0x01, 0x04, 0x0A, 0x14, 0x03, 0x0E, 0x06, 0x08, 0x13, 
    0x12, 0x0F, 0x16, 0x09, 0x0C, 0x02, 0x11, 0x19, 0x00, 0x05, 0x01, 0x1B, 0x13, 0x15, 0x17, 0x1A, 
    0x14, 0x1C, 0x1F, 0x0A, 0x0D, 0x06, 0x10, 0x0E, 0x1D, 0x07, 0x0B, 0x1E, 0x04, 0x18, 0x08, 0x03, 
    0x05, 0x11, 0x0D, 0x08, 0x0F, 0x0E, 0x17, 0x0C, 0x15, 0x1D, 0x01, 0x02, 0x0B, 0x1A, 0x07, 0x1E, 
    0x14, 0x09, 0x13, 0x1F, 0x1B, 0x12, 0x16, 0x00, 0x0A, 0x06, 0x10, 0x04, 0x03, 0x1C, 0x18, 0x19, 
    0x0D, 0x11, 0x08, 0x15, 0x1E, 0x12, 0x04, 0x05, 0x16, 0x14, 0x00, 0x1D, 0x13, 0x09, 0x1C, 0x19, 
    0x17, 0x1A, 0x0C, 0x06, 0x1F, 0x01, 0x0F, 0x0A, 0x1B, 0x18, 0x10, 0x03, 0x0B, 0x07, 0x0E, 0x02, 
    0x14, 0x04, 0x05, 0x03, 0x1A, 0x00, 0x16, 0x0F, 0x1C, 0x1F, 0x09, 0x06, 0x15, 0x0C, 0x02, 0x19, 
    0x13, 0x18, 0x01, 0x0B, 0x10, 0x0A, 0x0D, 0x08, 0x07, 0x1E, 0x12, 0x17, 0x11, 0x0E, 0x1B, 0x1D, 
    0x16, 0x1E, 0x1B, 0x14, 0x10, 0x02, 0x06, 0x15, 0x0C, 0x18, 0x1C, 0x11, 0x0A, 0x08, 0x03, 0x1D, 
    0x0B, 0x1A, 0x0F, 0x09, 0x04, 0x07, 0x13, 0x1F, 0x05, 0x0E, 0x17, 0x19, 0x01, 0x12, 0x00, 0x0D, 
} ;

//
// Funzione Encrypt/Decrypt 32 bit
//
unsigned long chiper(unsigned long nibble, unsigned long value, unsigned char type)
{
	unsigned char x;
	unsigned long bit;
	unsigned long chiper;

	// Inizializzo variabili
	chiper = 0x00000000;	

	// Loop per 32-bit
	for(x=0; x<32; x++)
	{
		bit = value & (0x00000001 << x);					
		
		if(bit != 0)
		{
			chiper |= 0x00000001 << (type ? tavola_encrypt[(nibble << 5) + x] : tavola_decrypt[(nibble << 5) + x]);
		}
	}
	
	return chiper;
}

//
// Funzione di Decrypt Key Code
//
unsigned long decrypt(char * keyascii, char * serascii)
{
	char * point;	
	unsigned char x;	
	unsigned long shift;
	unsigned long key;
	unsigned long keytemp;
	unsigned long seriale;

	// Converto Key in unsigned long
	key = strtoul(keyascii, NULL, 10);

	// Converto Seriale Strumento in unsigned long
	seriale = strtoul(serascii, &point, 10) * 1000;

	// Controllo fine seriale
	if(point[0] == '/')
	{
		// Aggungo altra parte seriale
		seriale += strtoul(&point[1], NULL, 10);
	}

	// Inizializzo variabili	
	shift   = seriale;		// Seriale Strumento
	keytemp = key;			// Seriale immesso per opzione

	// Inizializzo contatori loop
	for(x=0; x<8; x++)
	{
		keytemp = chiper((shift & 0x0F), (keytemp - tavola[shift & 0x0F]), DECRYPT);

		shift = shift >> 4;	
	}

	// Esco con valore opzione
	return keytemp;
}

//
// Funzione di Encrypt Opzione
//
unsigned long encrypt(unsigned long opzione, char * serascii)
{
	char * point;	
	unsigned char x;	
	unsigned long shift;
	unsigned long seriale;

	// Converto Seriale Strumento in unsigned long
	seriale = strtoul(serascii, &point, 10) * 1000;

	// Controllo fine seriale
	if(point[0] == '/')
	{
		// Aggungo altra parte seriale
		seriale += strtoul(&point[1], NULL, 10);
	}

	// Inizializzo contatori loop
	for(x=0; x<8; x++)
	{
		shift = seriale >> (4 * (7-x));

		opzione = chiper((shift & 0x0F), opzione, ENCRYPT) + tavola[shift & 0x0F];				
	}

	// Esco con valore opzione
	return opzione;
}

//
// Valori Strumento FSP "http://www.rohde-schwarz.it/it/prodotti/test_and_measurement/spectrum_analysis/FSP-|--|-100-|-6394.html"
//
char KeyString []	= {"0123456789"};		// Opzione originale ottenuta da "Rohde & Schwarz", per verifica funzionamento Keygen
char SerString []	= {"xxxxxx/xxx"};		// Seriale dello strumento

//
// Programma Calcolo Codici Opzioni FSP
//
int main(void)
{
	unsigned long key;
	option_type * option = option_list;

	//
	// Test funzionamento con opzione valida
	//

	// Decodifica Opzione
	decrypt(KeyString, SerString);

	// Codifica Opzione
	key = encrypt(option->raw_option, SerString);	

	//
	// Calcolo tutte le opzioni "Funzionanti" per Seriale
	//

	// Per tutte le opzioni dispinibili
	while (option->raw_option)
	{
		// Controllo se opzione valida
		if(option->valid_option == TRUE)
		{
			// Calcolo chiave
			key = encrypt(option->raw_option, SerString);	

			// Stampo valore opzione da immettere nello strumento
			printf("%010lu - %s\r\n", key, option->descr_option);
		}

		// Opzione successiva
		option++;
	}
}
